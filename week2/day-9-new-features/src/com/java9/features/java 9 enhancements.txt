Java 9 features:
______________________________
1. Need of private Methods inside interface
2. Try with Resources Enahancements
3. In JDK 9, Usage of Diamond Operator extended to Anonymous classes also
4. SafeVarargs Annotation Enhancements
5. Factory Methods for creating unmodifiable Collections
6. Creation of unmodifiable Map (Immutable Map) with Java 9 Factory Methods
7. Java 9 Enhancements for Stream API
8. JShell
9. Java Platform Module System (JPMS)
10. Process API Updates (JEP-102)
11. Java 9 HTTP/2 Client




1. Need of private Methods inside interface:

If several default methods having same common functionality then there may be a
chance of duplicate code(Redundant Code)


public interface Java8DBLogging {

	default void logInfo(String message) {
		//	Step1: Connect to DataBase
		//	Setp2: Log Info Message
		//	Setp3: Close the DataBase connection
	}

	default void logWarn(String message) {
		//Step1: Connect to DataBase
		//Setp2: Log Warn Message
		//Setp3: Close the DataBase connection
	}

	default void logError(String message) {
		//Step1: Connect to DataBase
		//Setp2: Log Error Message
		//Setp3: Close the DataBase connection
	}

	default void logFatal(String message) {
		//Step1: Connect to DataBase
		//Setp2: Log Fatal Message
		//Setp3: Close the DataBase connection
	}
}

voilation of DRY
____________________
package com.demo.A_defaultmethod;

public interface Java9DBLogging {
	default void logInfo(String message) {
		log(message, "INFO");
	}

	default void logWarn(String message) {
		log(message, "WARN");
	}

	default void logError(String message) {
		log(message, "ERROR");
	}

	default void logFatal(String message) {
		log(message, "FATAL");
	}

	private void log(String msg, String logLevel) {
		//Step1: Connect to DataBase
		//Step2: Log Message with the Provided logLevel
		//Step3: Close the DataBase Connection
	}
}



2. Try with Resources Enahancements
__________________________________
From JDK 9 onwards we can use the resource reference variables which are created
outside of try block directly in try block resources list.i.e The resource reference variables
need not be local to try block.
Scanner scanner =new Scanner(System.in);
try(scanner)
{
// It is valid in JDK 9 but in valid until JDK 1.8V
}
But make sure resource(scanner) should be either final or effectively final. Effectively final
means we should not perform reassignment.



3. In JDK 9, Usage of Diamond Operator extended to Anonymous classes also.
_________________________________________________________________________

ArrayList<String> l = new ArrayList<String>(){
};
We are creating a child class that extends ArrayList class without name(Anonymous class) and we
are creating object for that child class.
From JDK 9 onwards we can use Diamond Operator for Anonymous Classes also.
ArrayList<String> l = new ArrayList<>(){

 };







4. SafeVarargs Annotation Enhancements
____________________________________

public class A_Heap_pollution {

	public static void main(String[] args) {
		List<String> l1 = Arrays.asList("A", "B");
		List<String> l2 = Arrays.asList("C", "D");
		m1(l1, l2);
	}

	public static void m1(List<String>... l) {
		Object[] a = l;// we can assign List[] to Object[]
		a[0] = Arrays.asList(10, 20);
		String name = (String) l[0].get(0);// String type pointing to Integer type

		System.out.println(name);
	}
}


javac -Xlint:unchecked A_Heap_pollution.java

Very few Var-arg Methods causes Heap Pollution, not all the var-arg methods. If we know that our
method won't cause Heap Pollution, then we can suppress compiler warnings with @SafeVarargs
annotation.

import java.util.*;

public class B_No_Heap_pollution {
	public static void main(String[] args) {

		List<String> l1 = Arrays.asList("A", "B");
		List<String> l2 = Arrays.asList("C", "D");
		m1(l1, l2);
	}

	@SafeVarargs
	public static void m1(List<String>... l) {
		for (List<String> l1 : l) {
			System.out.println(l1);
		}
	}
}


In the program, inside m1() method we are not performing any reassignments. Hence there is no
chance of Heap Pollution Problem. Hence we can suppress Compiler generated warnings with
@SafeVarargs annotation.


Java 9 Enhancements to @SafeVarargs Annotation:
_____________________________________________
@SafeVarargs Annotation introduced in Java 7.
Unitl Java 8, this annotation is applicable only for static methods,final methods and constructors.
But from Java 9 onwards,we can also use for private instance methods also


import java.util.List;

public class Demo {
	@SafeVarargs // valid
	public  Demo(List<String>... l) {
	}

	@SafeVarargs // valid
	public static void m1(List<String>... l) {
	}

	@SafeVarargs // valid
	public final void m2(List<String>... l) {
	}

	@SafeVarargs // valid in Java 9 but not in Java 8
	private void m3(List<String>... l) {
	}
}



Factory Methods for creating unmodifiable Collections
_____________________________________________________

               // Creation of unmodifiable List/ Set object
		List<String> books = new ArrayList<String>();
		books.add("head fist");
		books.add("thinking in java");
		books.add("sprng in action");
		books.add("think and grow rich");
		books = Collections.unmodifiableList(books);

		// Creation of unmodifiable Set Object

		Set<String> booksSet = new HashSet<String>();
		booksSet.add("head fist");
		booksSet.add("thinking in java");
		booksSet.add("sprng in action");
		booksSet.add("think and grow rich");
		booksSet = Collections.unmodifiableSet(booksSet);

		// Creation of unmodifiable Map object

		Map<String, String> map = new HashMap<String, String>();
		map.put("A", "Apple");
		map.put("B", "Banana");
		map.put("C", "Cat");
		map.put("D", "Dog");
		map = Collections.unmodifiableMap(map);


This way of creating unmodifiable Collections is verbose and not convenient.
It increases length of the code and reduces readability.
JDK Engineers addresses this problem and introduced several factory methods for creating unmodifiable collections.
Creation of unmodifiable List (Immutable List) with Java 9 Factory Methods:

Java 9 List interface defines several factory methods for this.
______________________________
1. static <E> List<E> of()
2. static <E> List<E> of(E e1)
3. static <E> List<E> of(E e1, E e2)
4. static <E> List<E> of(E e1, E e2, E e3)
5. static <E> List<E> of(E e1, E e2, E e3, E e4)
6. static <E> List<E> of(E e1, E e2, E e3, E e4, E e5)
7. static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6)
8. static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
9. static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)
10.static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)
11.static <E> List<E>  of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e1)
12. static <E> List<E> of(E ...elements)

Upto 10 elements the matched method will be executed and for more than 10 elements
internally var-arg method will be called.JDK Enginerrs identified List of upto 10 elements is
the common requirement and hence they provided the corresponding methods. For
remaining cases var-arg method will be executed,which is very costly. These many
methods just to improve performance.

To create unmodifiable List with Java 9 Factory Methods.
__________________________________________________

	List<String> booksList = 
				List.of("head fist", "thinking in java", "sprng in action", "think and grow rich");
		Set<String> booksSet = 
				Set.of("head fist", "thinking in java", "sprng in action", "think and grow rich");


Note:	
1. null is not allowed in the unmodifiable list 
 List<String> fruits = List.of("Apple","Banana",null); //NPEx

While using these factory methods if any element is null then we will get NullPointerException.

2. After creating the List object,if we are trying to change the content(add|remove|replace elements)then we will get UnsupportedOperationException b'z List is immutable(unmodifiable).

List<String> fruits=List.of("Apple","Banana","Mango");
fruits.add("Orange"); //UnsupportedOperationException
fruits.remove(1);//UnsupportedOperationException
fruits.set(1,"Orange"); //UnsupportedOperationException


Creation of unmodifiable Map (Immutable Map) with Java 9 Factory Methods:
______________________________________________________________________
Java 9 Map interface defines of() and ofEntries() Factory methods for this purpose.
1. static <K,V> Map<K,V> of()
2. static <K,V> Map<K,V> of(K k1,V v1)
3. static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2)
4. static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3)
5. static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4)
6. static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5)
7. static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5,K k6,V v6)
8. static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5,K k6,V v6,k7,V v7)
9. static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5,K k6,V v6,k7,V v7,K k8,V v8)
10.static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5,K k6,V v6,Kk7,V v7,K k8,V v8,K k9,V v9)
11.static <K,V> Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5,K k6,V v6,Kk7,V v7,K k8,V v8,K k9,V v9,K k10,V v10)
12.static <K,V> Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)

Note:
Up to 10 entries,it is recommended to use of() methods and for more than 10 items we should use ofEntries() method.
Eg:
Map<String,String> map=Map.of("A","Apple","B","Banana","C","Cat","D","Dog");



/*
		 * Up to 10 entries,it is recommended to use of() methods and for more than 10
		 * items we should use ofEntries() method.
		 */

		Map<String, String> map = Map.of("A", "Apple", "B", "Banana", "C", "Cat", "D", "Dog");

		/*
		 * How to use Map.ofEntries() method: Map interface contains static Method
		 * entry() to create immutable Entry objects
		 */
		Map.Entry<String, String> e = Map.entry("A", "Apple");
		/*
		 * This Entry object is immutable and we cannot modify its content. If we are
		 * trying to change we will get RE: UnsupportedOperationException
		 */
		e.setValue("coder");// UnsupportedOperationException

		Map.Entry<String, String> e1 = Map.entry("A", "Apple");
		Map.Entry<String, String> e2 = Map.entry("B", "Banana");
		Map.Entry<String, String> e3 = Map.entry("C", "Cat");
		Map<String, String> m = Map.ofEntries(e1, e2, e3);
		System.out.println(m);

		// In Short way we can also create as follows.

		Map<String, String> map2 = Map
				.ofEntries(Map.entry("A", "Apple"), Map.entry("B", "Banana"),
				Map.entry("C", "Cat"), Map.entry("D", "Dog"));


Note : Null is also not allowed in these collection




Java 9 Enhancements for Stream API
________________________________

In Java 9 as the part of Stream API, the following new methods introduced.
1. takeWhile()
2. dropWhile()
3. Stream.iterate()
4. Stream.ofNullable()

Note: takeWhile() and dropWhile() methods are default methods and iterate() and ofNullable()
are static methods of Stream interface.

1. default Stream takeWhile(Predicate p)
_____________________________________
It is the default method present in Stream interface.
It returns the stream of elements that matches the given predicate.
It is similar to filter() method.

Difference between takeWhile() and filter():
_____________________________________
filter() method will process every element present in the stream and consider the element if predicate is true.
But, in the case of takeWhile() method, there is no guarantee that it will process every element of
the Stream. It will take elements from the Stream as long as predicate returns true. If predicate
returns false, at that point onwards remaining elements won't be processed, i.e rest of the Stream
is discarded

public class Demo {
	public static void main(String[] args) {
		ArrayList<Integer> l1 = new ArrayList<Integer>();
		l1.add(2);
		l1.add(4);
		l1.add(1);
		l1.add(3);
		l1.add(6);
		l1.add(5);
		l1.add(8);
		System.out.println("Initial List:" + l1);
		List<Integer> l2 = l1.stream().filter(i -> i % 2 == 0).collect(Collectors.toList());
		System.out.println("After Filtering:" + l2);
		List<Integer> l3 = l1.stream().takeWhile(i -> i % 2 == 0).collect(Collectors.toList());
		System.out.println("After takeWhile:" + l3);
	}
}



JShell 
________
=> Jshell is also known as Interactive console.
=> REPL Tool (Read,Evaluate,Print and Loop)

=> By using this tool we can execute java code snippets and we can get immediate results.

=> By using this jshell we can test and execute java expressions,statements,methods,classes etc.It is
  useful for testing small code snippets very quickly,which can be plugged into our main coding
  based on our requirement.

=> Prior to Java 9 we cannot execute a single statement,expression,methods without full pledged
    classes. But in Java 9 with JShell we can execute any small piece of code without having complete
  class structure.

=> It is already there in other languages like Python,Swift,Lisp,Scala,Ruby etc..
	Python IDLE


Limitation:

=> JShell is not meant for Main Coding.We can use just to test small coding snippets,which can be
    used in our Main Coding.
=> JShell is not replacement of Regular Java IDEs like Eclpise,NetBeans etc

=> It is not that much impressed feature. All other languages like Python,LISP,Scala,Ruby,Swift etc
  are already having this REPL tools.


getting started :
--------------
jshell -v
| Welcome to JShell -- Version 9
| For an introduction type: /help intro

exit
--------
jshell> /exit
| Goodbye

Examples:
-------------
jshell> 10+20
$1 ==> 30

jshell> System.out.println("buzy coder")
buzy coder

jshell> Math.max(10,20)



The following packages are bydefault available to the Jshell and we are not required to
_____________________________________
import. We can check with /imports command
jshell> /imports
| import java.io.*
| import java.math.*
| import java.net.*
| import java.nio.file.*
| import java.util.*
| import java.util.concurrent.*
| import java.util.function.*
| import java.util.prefs.*
| import java.util.regex.*


Ex:
jshell> ArrayList<String> l=new ArrayList<String>();
l ==> []
jshell> l.add("Sunny");l.add("Bunny");l.add("Chinny");
$2 ==> true
$3 ==> true
$4 ==> true
jshell> l
l ==> [Sunny, Bunny, Chinny]
jshell> l.isEmpty()
$6 ==> false
jshell> l.get(2)
$7 ==> "Chinny"
jshell> l.get(10)
| java.lang.IndexOutOfBoundsException thrown: Index 10 out-of-bounds for length 3
jshell> l.size()
$9 ==> 3
jshell> if(l.isEmpty()) System.out.p


Java Platform Module System (JPMS) Jigsaw project
___________________________________

=> Until Java 1.8 version we can develop applications by writing several classes, interfaces and
enums. We can places these components inside packages and we can convert these packages into
jar files. By placing these jar files in the classpath, we can run our applications. An enterprise
application can contain 1000s of jar files also.

=> Hence jar file is nothing but a group of packages and each package contains several .class files.
But in Java 9, a new construct got introduced which is nothing but 'Module'. 

=> From java 9 version onwards we can develop applications by using module concept.
 Module is nothing but a group of packages similar to jar file. But the specialty of module when
 compared with jar file is, module can contain configuration information also.

=> Hence module is more powerful than jar file. The configuration information of module should be
specified in a special file named with module-info.java

=> Every module should compulsory contains module-info.java, otherwise JVM won't consider that as
a module of Java 9 platform.

=> All classes of Java 9 are grouped into several modules (around 98)
like
java.base
java.logging
java.sql
java.desktop(AWT/Swing)
java.rmi etc
java.base module acts as base for all java 9 modules.



What is the need of JPMS?
____________________________
Application development by using jar file concept has several serious problems.

Problem-1: Unexpected NoClassDefFoundError in middle of program execution
__________________________________________________________________________
	=> There is no way to specify jar file dependencies until java 1.8V.At runtime,if any dependent jar file
	is missing then in the middle of execution of our program, we will get NoClassDefFoundError :(



	=> At runtime, by mistake if pack1 is not available then after executing some part of the code in the
		middle, we will get NoClassDefFoundError.

	D:\demo>java Test
	Test class main
	pack2.A2 method
	
	Exception in thread "main" java.lang.NoClassDefFoundError: pack1/A1

	=> But in Java9, there is a way to specify all dependent modules information in module-info.java. 
	If any module is missing then at the beginning only, JVM will identify and won't start its execution.

	Hence there is no chance of raising NoClassDefFoundError in the middle of execution.


	Ex:
	1. create a class A1

package pack1;

public class A1 {
	public void m1() {
		System.out.println("pack1.A");
	}
}

1. create a class A2

package pack2;

import pack1.A1;

public class A2 {
	public void m2() {
		System.out.println("pack2.A2 method");
		A1 a = new A1();
		a.m1();
	}
}


3. create test class
import pack2.A2;

class Test {
	public static void main(String[] args) {
		System.out.println("Test class main");
		A2 a = new A2();
		a.m2();
	}
}


4. compile classes with packages:

javac -d . A1.java
javac -d . A2.java

javac Test.java
java Test

what if package1 folder is not there ...delteted

 java Test
Test class main
pack2.A2 method
Exception in thread "main" java.lang.NoClassDefFoundError: pack1/A1
	at pack2.A2.m2(A2.java:8)
	at Test.main(Test.java:7)
Caused by: java.lang.ClassNotFoundException: pack1.A1
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	... 2 more





Problem-2: Version Conflicts or Shadowing Problems
___________________________________________________
	=> If JVM required any .class file, then it always searches in the classpath from left to right until
	required match found.

	classpath = jar1;jar2;jar3;jar4

	=> If jar4 requires Test.class file of jar3.But Different versions of Test.class is available in jar1, jar2 and
	jar3. 

	=> In this case jar1 Test.class file will be considered, because JVM will always search from Left to
	Right in the classpath. It will create version conflicts and causes abnormal behavior of program


	=>But in java9 module system, there is a way to specify dependent modules information for every
	module seperately.JVM will always consider only required module and there is no order
	importance. Hence version conflicts won't be raised in Java 9


Problem 3: Security problem ==There is no mechanism to hide packages of jar file.
_____________________________
	=> Assume pack1 can be used by other jar files, but pack2 is just for internal purpose only.

	=> Until Java 8 there is no way to specify this information. Everything in jar file is public and available
	to everyone. Hence there may be a chance of Security problems.

	=> public is too much public in jar files.

	=> But in Java 9 Module system, we can export particular package of a module. Only this exported
           package can be used by other modules. The remaining packages of that module are not visible to
           outside. Hence Strong encapsulation is available in Java 9 and there is no chance of security
	problems.

	=> Even though class is public, if module won't export the corresponding package, then it cannot be
        accessed by other modules. Hence public is not really that much public in Java 9 Module System.
         Module can offer Strong Encapsulation than Jar File.


Problem 4: JDK/JRE having Monolithic Structure and Very Large Size
___________________________________________________________________
=> The number of classes in Java is increasing very rapidly from version to version.
    JDK 1.0V having 250+ classes
    JDK 1.1V having 500+ classes
     ...
    JDK 1.8V having 4000+ classes

	And all these classes are available in rt.jar.

	=> Hence the size of rt.jar is increasing from version to version.

	=> The size of rt.jar in Java 1.8Version is around 60 MB.

	=> To run small program also, total rt.jar should be loaded, which makes our application heavy
      weight and not suitable for IOT applications and micro services which are targeted for portable
       devices.


	=> It will create memory and performance problems also.

	(This is something like inviting a Big Elephant in our Small House: Installing a Heavy Weight Java
		application in a small portable device).

	=> But in java 9, rt.jar removed. Instead of rt.jar all classes are maintained in the form of modules.

	=> Hence from Java 9 onwards JDK itself modularized. Whenever we are executing a program only
          required modules will be loaded instead of loading all modules, which makes our application light
          weighted.

	=> Now we can use java applications for small devices also. From Java 9 version onwards, by using
        JLINK , we can create our own very small custom JREs with only required modules.


What is a Module:
_______________________
	=> Module is nothing but collection of packages. 
	Each module should compulsory contains a special

	configuration file: module-info.java.
	
	module-info.java
	We can define module dependencies inside module-info.java file.

	module moduleName
	{
		Here we have to define module dependencies which represents
		1. What other modules required by this module?
		2. What packages exported by this module for other modules? etc
	}



Hello world module:
__________________
step :
	src
		moduleA
			pack1	---> Test.java
			module-nfo.java

package pack1;
public class Test{
public static void main(String[] args){
	System.out.println("First Module in JPMS");
 }
}

creating module:
javac --module-source-path src -d out -m moduleA

running code with module:
java --module-path out -m moduleA/pack1.Test


Case-1:If module-info.java is not available then the code won't compile and we will get error. 

Hence module-info.java is mandatory for every module.

javac --module-source-path src -d out -m moduleA
error: module moduleA not found in module source path

Case-2:Every class inside module should be part of some package, otherwise we will get compile time

error saying : unnamed package is not allowed in named modules
In the above application inside Test.java if we comment package statement


Case-3:The module name should not ends with digit(like module1,module2 etc),otherwise we will get
warning at compile time.
javac --module-source-path src -d out -m module1
warning: [module] module name component module1 should avoid terminal digits


inter module dependencies
_______________________
refer code:
javac --module-source-path src -d out -m moduleA,moduleB
java --module-path out -m moduleB/pack2.Test


Case-1:
Even though class A is public, if moduleA won't export pack1, then moduleB cannot access A class.

Case-2:
We have to export only packages. If we are trying to export modules or classes then we will get
compile time error.


Case-3:
If moduleB won't use "requires moduleA" directive then moduleB is not allowed to use members
of moduleA, even though moduleA exports.

MCQ:
Which of the following are meaningful?
module moduleName
{
1. requires modulename;
2. requires modulename.packagename;
3. requires modulename.packagename.classname;
4. exports modulename;
5. exports packagename;
6. exports packagename.classname;
}

Answer: 1 & 5 are Valid
Note: We can use exports directive only for packages but not modules and classes, and we can
use requires directive only for modules but not for packages and classes.
Note: To access members of one module in other module, compulsory we have to take care the
following 3 things.
1. The module which is accessing must have requires dependency
2. The module which is providing functionality must have exports dependency
3. The member must be public.


JPMS vs NoClassDefFoundError:
___________________________
refer ex3

javac --module-source-path src -d out -m moduleA,moduleB,moduleC
java --module-path out -m moduleC/pack3.Test


Test class main method
Method of moduleB
Method of moduleA

If we delete compiled code of module (inside out folder), then JVM will raise error at the
beginning only and JVM won't start program execution.

java --module-path out -m moduleC/pack3.Test

Error occurred during initialization of boot layer
java.lang.module. FindException: Module moduleA not found, required by moduleB


But in Non Modular programming, JVM will start execution and in the middle, it will raise NoClassDefFoundError.
Hence in Java Platform Module System, there is no chance of getting NoClassDefFoundError in the
middle of program execution


Transitive Dependencies (requires with transitive Keyword):
____________________________________________________________
A-> B, B-> C ==> A->C

This property in mathematics is called Transitive Property.

Student1 requires Material, only for himself, if any other person asking he won't share.
module student1{
  requires material;
}

"Student1 requires material not only for himself, if any other person asking him, he will share it"

module Student1{
  requires transitive material;
}


module moduleA{
exports pack1;
}
module moduleB{
 requires transitive moduleA;
}
module moduleC{
requires moduleB;
}

Optional Dependencies (Requires Directive with static keyword):
______________________________________________________________
If Dependent Module should be available at compile time but optional at runtime, then such type
of dependency is called Otional Dependency. 
We can specify optional dependency by using static keyword.


moduleA should be available at the time of compilation and runtime. It is not optional dependency.
module moduleB{
 requires  moduleA;
}


At the time of compilation moduleA should be available, but at runtime it is optional. i.e., at
runtime even moduleA is not available JVM will execute code.
module moduleB{
 requires static moduleA;
}


LINK (Java Linker)
_____________________
Until 1.8 version to run a small Java program (like Hello World program) also, we should use a
bigger JRE which contains all java's inbuilt 4300+ classes. It increases the size of Java Runtime
environment and Java applications. Due to this Java is not suitable for IOT devices and Micro
Services. (No one invite a bigger Elephant into their small house)


How to use JLINK: Demo Program
____________________________
 consider ex4:

 javac --module-source-path src -d out -m moduleA,moduleB,moduleC
 java --module-path out -m moduleC/pack3.Test


Creation of our own JRE only with required modules:
__________________________________________
demoModule requires java.base module. Hence add java.base module to out directory
(copy java.base.jmod from jdk-9\jmods to out folder)

Now we can create our own JRE with JLINK command
jlink --module-path out --add-modules demoModule,java.base --output rajjre





